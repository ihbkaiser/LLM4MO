[
     {
          "algorithm": "\nProposed algorithm: At each step, calculate the combined cost metric for each unvisited node by summing the corresponding distances from the current node in both distance matrices, then select the node with the minimum combined cost metric as the next node.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix_1, distance_matrix_2):\n    combined_costs = []\n    for node in unvisited_nodes:\n        combined_cost = distance_matrix_1[current_node, node] + distance_matrix_2[current_node, node]\n        combined_costs.append(combined_cost)\n    \n    next_node = unvisited_nodes[np.argmin(combined_costs)]\n    return next_node",
          "objective": [
               11.52454,
               12.24184
          ],
          "other_inf": null
     },
     {
          "algorithm": "\nThe algorithm selects the next node by considering the combination of the two distance matrices, favoring nodes that have shorter distances in both matrices simultaneously.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix_1, distance_matrix_2):\n    min_combined_distance = float('inf')\n    next_node = None\n    \n    for node in unvisited_nodes:\n        if node != current_node and node != destination_node:\n            combined_distance = distance_matrix_1[current_node][node] + distance_matrix_2[current_node][node]\n            \n            if combined_distance < min_combined_distance:\n                min_combined_distance = combined_distance\n                next_node = node\n\n    return next_node",
          "objective": [
               11.52454,
               12.24184
          ],
          "other_inf": null
     },
     {
          "algorithm": "\nNovel algorithm: At each step, select the next node based on the minimum ratio of the sum of distances in both matrices to the sum of distances in matrix 1.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix_1, distance_matrix_2):\n    min_ratio = np.inf\n    next_node = None\n    for node in unvisited_nodes:\n        total_distance = distance_matrix_1[current_node][node] + distance_matrix_2[current_node][node]\n        ratio = total_distance / distance_matrix_1[current_node][node]\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n    return next_node",
          "objective": [
               32.35392,
               8.70372
          ],
          "other_inf": null
     },
     {
          "algorithm": "\nNovel algorithm: In each step, calculate the sum of the distances from the current node to each unvisited node in both matrices, and select the node with the minimum sum as the next node.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix_1, distance_matrix_2):\n    min_sum = np.inf\n    next_node = None\n    for node in unvisited_nodes:\n        sum_dist = distance_matrix_1[current_node, node] + distance_matrix_2[current_node, node]\n        if sum_dist < min_sum:\n            min_sum = sum_dist\n            next_node = node\n    return next_node",
          "objective": [
               11.52454,
               12.24184
          ],
          "other_inf": null
     },
     {
          "algorithm": "\nNovel algorithm: At each step, calculate a combined score for each unvisited node as the sum of the normalized distances in both distance matrices from the current node to the unvisited node, and select the unvisited node with the minimum combined score as the next node to visit.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix_1, distance_matrix_2):\n    min_combined_score = np.inf\n    next_node = None\n    \n    for node in unvisited_nodes:\n        if node == current_node:\n            continue\n        \n        score = np.sum(distance_matrix_1[current_node][node] / np.max(distance_matrix_1) + \n                        distance_matrix_2[current_node][node] / np.max(distance_matrix_2))\n        \n        if score < min_combined_score:\n            min_combined_score = score\n            next_node = node\n    \n    return next_node",
          "objective": [
               11.57628,
               12.12329
          ],
          "other_inf": null
     },
     {
          "algorithm": "\nNovel algorithm: The next node is selected by finding the node in the unvisited nodes that minimizes the sum of the value in the row of the current node in distance matrix 1 and the value in the column of the destination node in distance matrix 2.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix_1, distance_matrix_2):\n    min_cost = np.inf\n    next_node = None\n    \n    for node in unvisited_nodes:\n        cost = distance_matrix_1[current_node][node] + distance_matrix_2[node][destination_node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n    \n    return next_node",
          "objective": [
               10.89516,
               19.94211
          ],
          "other_inf": null
     },
     {
          "algorithm": "\nOur novel algorithm selects the next node by calculating the cumulative sum of distances from the current node to all unvisited nodes in both distance matrices, and then choosing the node that minimizes the sum of the two metrics.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix_1, distance_matrix_2):\n    total_distances = distance_matrix_1[current_node][unvisited_nodes] + distance_matrix_2[current_node][unvisited_nodes]\n    next_node = unvisited_nodes[np.argmin(total_distances)]\n    return next_node",
          "objective": [
               11.52454,
               12.24184
          ],
          "other_inf": null
     },
     {
          "algorithm": "\nNovel algorithm: \nSelect the next node based on the sum of the distances from the current node to each unvisited node in both distance matrices, prioritizing the node with the smallest total distance.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix_1, distance_matrix_2):\n    \n    min_total_distance = float('inf')\n    next_node = None\n    \n    for node in unvisited_nodes:\n        total_distance = distance_matrix_1[current_node][node] + distance_matrix_2[current_node][node]\n        \n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n    \n    return next_node",
          "objective": [
               11.52454,
               12.24184
          ],
          "other_inf": null
     },
     {
          "algorithm": "\nMy algorithm selects the next node based on the highest average distance to all unvisited nodes in both distance matrices, favoring exploration to potentially new regions.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix_1, distance_matrix_2):\n    max_avg_distance = -1\n    next_node = None\n    \n    for node in unvisited_nodes:\n        avg_distance = (np.mean(distance_matrix_1[current_node]) + np.mean(distance_matrix_2[current_node])) / 2\n        if avg_distance > max_avg_distance:\n            max_avg_distance = avg_distance\n            next_node = node\n    \n    return next_node",
          "objective": [
               11.91855,
               11.70492
          ],
          "other_inf": null
     },
     {
          "algorithm": "\nProposed algorithm: At each step, calculate a combined cost metric for all unvisited nodes based on both distance matrices, and select the node with the lowest combined cost as the next node.\n",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix_1, distance_matrix_2):\n    combined_cost = np.zeros(len(unvisited_nodes))\n    for i, node in enumerate(unvisited_nodes):\n        combined_cost[i] = distance_matrix_1[current_node][node] + distance_matrix_2[current_node][node] + distance_matrix_1[node][destination_node] + distance_matrix_2[node][destination_node]\n    \n    next_node = unvisited_nodes[np.argmin(combined_cost)]\n    \n    return next_node",
          "objective": [
               13.45789,
               12.75159
          ],
          "other_inf": null
     }
]